# Multi Threading(多线程)

参考书籍：

> 深入理解Java并发编程
>
> Java并发编程

常见问题

> 多线程、同步/异步、线程安全(线程之间通讯)、java并发包、线程池原理
>
> 线程池调优、锁概念、同步原理

## 1. [进程和线程之由来]( https://www.cnblogs.com/dolphin0520/p/3910667.html )

### 1.1 操作系统中为什么会出现进程

​		说起进程的由来，我们需要从操作系统的发展历史谈起。

　　也许在今天，我们无法想象在很多年以前计算机是什么样子。我们现在可以用计算机来做很多事情：办公、娱乐、上网，但是在计算机刚出现的时候，是为了解决数学计算的问题，因为很多大量的计算通过人力去完成是很耗时间和人力成本的。在最初的时候，计算机只能接受一些特定的指令，用户输入一个指令，计算机就做一个操作。当用户在思考或者输入数据时，计算机就在等待。显然这样效率和很低下，因为很多时候，计算机处于等待用户输入的状态。

　　那么能不能把一系列需要操作的指令预先写下来，形成一个清单，然后一次性交给计算机，计算机不断地去读取指令来进行相应的操作？就这样，批处理操作系统诞生了。用户可以将需要执行的多个程序写在磁带上，然后交由计算机去读取并逐个地执行这些程序，并将输出结果写到另一个磁带上。

　　虽然批处理操作系统的诞生极大地提高了任务处理的便捷性，但是仍然存在一个很大的问题：

　　假如有两个任务A和B，任务A在执行到一半的过程中，需要读取大量的数据输入（I/O操作），而此时CPU只能静静地等待任务A读取完数据才能继续执行，这样就白白浪费了CPU资源。人们于是想，能否在任务A读取数据的过程中，让任务B去执行，当任务A读取完数据之后，让任务B暂停，然后让任务A继续执行？

　　但是这样就有一个问题，原来每次都是一个程序在计算机里面运行，也就说内存中始终只有一个程序的运行数据。而如果想要任务A执行I/O操作的时候，让任务B去执行，必然内存中要装入多个程序，那么如何处理呢？多个程序使用的数据如何进行辨别呢？并且当一个程序运行暂停后，后面如何恢复到它之前执行的状态呢？

　　这个时候人们就发明了进程，用进程来对应一个程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。并且进程保存了程序每个时刻的运行状态，这样就为进程切换提供了可能。当进程暂时时，它会保存当前进程的状态（比如进程标识、进程的使用的资源等），在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。

　　这就是并发，能够让操作系统从宏观上看起来同一个时间段有多个任务在执行。换句话说，进程让操作系统的并发成为了可能。

　　注意，虽然并发从宏观上看有多个任务在执行，但是事实上，任一个具体的时刻，只有一个任务在占用CPU资源（当然是对于单核CPU来说的）。

### 1.2 为什么会出现线程

​		在出现了进程之后，操作系统的性能得到了大大的提升。虽然进程的出现解决了操作系统的并发问题，但是人们仍然不满足，人们逐渐对实时性有了要求。因为一个进程在一个时间段内只能做一件事情，如果一个进程有多个子任务，只能逐个地去执行这些子任务。比如对于一个监控系统来说，它不仅要把图像数据显示在画面上，还要与服务端进行通信获取图像数据，还要处理人们的交互操作。如果某一个时刻该系统正在与服务器通信获取图像数据，而用户又在监控系统上点击了某个按钮，那么该系统就要等待获取完图像数据之后才能处理用户的操作，如果获取图像数据需要耗费10s，那么用户就只有一直在等待。显然，对于这样的系统，人们是无法满足的。

　　那么可不可以将这些子任务分开执行呢？即在系统获取图像数据的同时，如果用户点击了某个按钮，则会暂停获取图像数据，而先去响应用户的操作（因为用户的操作往往执行时间很短），在处理完用户操作之后，再继续获取图像数据。人们就发明了线程，让一个线程去执行一个子任务，这样一个进程就包括了多个线程，每个线程负责一个独立的子任务，这样在用户点击按钮的时候，就可以暂停获取图像数据的线程，让UI线程响应用户的操作，响应完之后再切换回来，让获取图像的线程得到CPU资源。从而让用户感觉系统是同时在做多件事情的，满足了用户对实时性的要求。

　　换句话说，进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。

　　但是要注意，一个进程虽然包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。

### 1.3 多线程并发

由于多个线程是共同占有所属进程的资源和地址空间的，那么就会存在一个问题：

1. 如果多个线程要同时访问某个资源，怎么处理？

　　这个问题就是后序文章中要重点讲述的同步问题。

　　那么可能有朋友会问，现在很多时候都采用多线程编程，那么是不是多线程的性能一定就优于单线程呢？

　　不一定，要看具体的任务以及计算机的配置。比如说：

　　对于单核CPU，如果是CPU密集型任务，如解压文件，多线程的性能反而不如单线程性能，因为解压文件需要一直占用CPU资源，如果采用多线程，线程切换导致的开销反而会让性能下降。

　　但是对于比如交互类型的任务，肯定是需要使用多线程的、

　　而对于多核CPU，对于解压文件来说，多线程肯定优于单线程，因为多个线程能够更加充分利用每个核的资源。

　　虽然多线程能够提升程序性能，但是相对于单线程来说，它的编程要复杂地多，要考虑线程安全问题。因此，在实际编程过程中，要根据实际情况具体选择。

## 2.  如何创建线程 

### 2.1 Java中关于应用程序和进程相关的概念

​		在Java中，一个应用程序对应着一个JVM实例（也有地方称为JVM进程），一般来说名字默认为java.exe或者javaw.exe（windows下可以通过任务管理器查看）。Java采用的是单线程编程模型，即在我们自己的程序中如果没有主动创建线程的话，只会创建一个线程，通常称为主线程。但是要注意，虽然只有一个线程来执行任务，不代表JVM中只有一个线程，JVM实例在创建的时候，同时会创建很多其他的线程（比如垃圾收集器线程）。

　　由于Java采用的是单线程编程模型，因此在进行UI编程时要注意将耗时的操作放在子线程中进行，以避免阻塞主线程（在UI编程时，主线程即UI线程，用来处理用户的交互事件）。

### 2.2  Java中如何创建线程 

​	在java中如果要创建线程的话，一般有两种方式：1）继承Thread类；2）实现Runnable接口。

#### 2.2.1 继承Thread类

继承Thread类的话，必须重写run方法，在run方法中定义需要执行的任务。

```java
class MyThread extends Thread{
    private static int num = 0;
     
    public MyThread(){
        num++;
    }
     
    @Override
    public void run() {
        System.out.println("主动创建的第"+num+"个线程");
    }
}
```

 创建好了自己的线程类之后，就可以创建线程对象了，然后通过start()方法去启动线程。注意，不是调用run()方法启动线程，run方法中只是定义需要执行的任务，如果调用run方法，即相当于在主线程中执行run方法，跟普通的方法调用没有任何区别，此时并不会创建一个新的线程来执行定义的任务。 

```java
public class Test {
    public static void main(String[] args)  {
        MyThread thread = new MyThread();
        thread.start();
    }
}
 
 
class MyThread extends Thread{
    private static int num = 0;
     
    public MyThread(){
        num++;
    }
     
    @Override
    public void run() {
        System.out.println("主动创建的第"+num+"个线程");
    }
}
```

 在上面代码中，通过调用start()方法，就会创建一个新的线程了。为了分清start()方法调用和run()方法调用的区别，请看下面一个例子： 

```java
public class Test {
    public static void main(String[] args)  {
        System.out.println("主线程ID:"+Thread.currentThread().getId());
        MyThread thread1 = new MyThread("thread1");
        thread1.start();
        MyThread thread2 = new MyThread("thread2");
        thread2.run();
    }
}
 
 
class MyThread extends Thread{
    private String name;
     
    public MyThread(String name){
        this.name = name;
    }
     
    @Override
    public void run() {
        System.out.println("name:"+name+" 子线程ID:"+Thread.currentThread().getId());
    }
}
```

结果：

![运行结果](https://images0.cnblogs.com/i/288799/201408/151004139364653.jpg)

从输出结果可以得出以下结论：

　　1）thread1和thread2的线程ID不同，thread2和主线程ID相同，说明通过run方法调用并不会创建新的线程，而是在主线程中直接运行run方法，跟普通的方法调用没有任何区别；

　　2）虽然thread1的start方法调用在thread2的run方法前面调用，但是先输出的是thread2的run方法调用的相关信息，说明新线程创建的过程不会阻塞主线程的后续执行。

#### 2.2.2 实现Runnable接口

　　在Java中创建线程除了继承Thread类之外，还可以通过实现Runnable接口来实现类似的功能。实现Runnable接口必须重写其run方法。

```java
public class Test {
    public static void main(String[] args)  {
        System.out.println("主线程ID："+Thread.currentThread().getId());
        MyRunnable runnable = new MyRunnable();
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
 
 
class MyRunnable implements Runnable{
     
    public MyRunnable() {
         
    }
     
    @Override
    public void run() {
        System.out.println("子线程ID："+Thread.currentThread().getId());
    }
}
```

​		Runnable的中文意思是“任务”，顾名思义，通过实现Runnable接口，我们定义了一个子任务，然后将子任务交由Thread去执行。注意，这种方式必须将Runnable作为Thread类的参数，然后通过Thread的start方法来创建一个新线程来执行该子任务。如果调用Runnable的run方法的话，是不会创建新线程的，这根普通的方法调用没有任何区别。

　　事实上，查看Thread类的实现源代码会发现Thread类是实现了Runnable接口的。

　　在Java中，这2种方式都可以用来创建线程去执行子任务，具体选择哪一种方式要看自己的需求。直接继承Thread类的话，可能比实现Runnable接口看起来更加简洁，但是由于Java只允许单继承，所以如果自定义类需要继承其他类，则只能选择实现Runnable接口。

### 2.3  Java中如何创建进程 

　在Java中，可以通过两种方式来创建进程，总共涉及到5个主要的类。

　　第一种方式是通过Runtime.exec()方法来创建一个进程，第二种方法是通过ProcessBuilder的start方法来创建进程。下面就来讲一讲这2种方式的区别和联系。

#### 2.3.1 Process类

##### 2.3.1.1 ProcessBuilder方法

　　首先要讲的是Process类，Process类是一个抽象类，在它里面主要有几个抽象的方法，这个可以通过查看Process类的源代码得知：

　　位于java.lang.Process路径下：

```java
public abstract class Process{
    
    abstract public OutputStream getOutputStream();   //获取进程的输出流
      
    abstract public InputStream getInputStream();    //获取进程的输入流
 
    abstract public InputStream getErrorStream();   //获取进程的错误流
 
    abstract public int waitFor() throws InterruptedException;   //让进程等待
  
    abstract public int exitValue();   //获取进程的退出标志
 
    abstract public void destroy();   //摧毁进程
}
```

1. 通过ProcessBuilder创建进程

   ProcessBuilder是一个final类，它有两个构造器：

   ```java
   public final class ProcessBuilder
   {
       private List<String> command;
       private File directory;
       private Map<String,String> environment;
       private boolean redirectErrorStream;
    
       public ProcessBuilder(List<String> command) {
       if (command == null)
           throw new NullPointerException();
       this.command = command;
       }
    
       public ProcessBuilder(String... command) {
       this.command = new ArrayList<String>(command.length);
       for (String arg : command)
           this.command.add(arg);
       }
   ....
   }
   ```

    构造器中传递的是需要创建的进程的命令参数，第一个构造器是将命令参数放进List当中传进去，第二构造器是以不定长字符串的形式传进去。 

    　那么我们接着往下看，前面提到是通过ProcessBuilder的start方法来创建一个新进程的，我们看一下start方法中具体做了哪些事情。下面是start方法的具体实现源代码： 

   ```java
   public Process start() throws IOException {
       // Must convert to array first -- a malicious user-supplied
       // list might try to circumvent the security check.
       String[] cmdarray = command.toArray(new String[command.size()]);
       for (String arg : cmdarray)
           if (arg == null)
           throw new NullPointerException();
       // Throws IndexOutOfBoundsException if command is empty
       String prog = cmdarray[0];
   
       SecurityManager security = System.getSecurityManager();
       if (security != null)
           security.checkExec(prog);
   
       String dir = directory == null ? null : directory.toString();
   
       try {
           return ProcessImpl.start(cmdarray,
                        environment,
                        dir,
                        redirectErrorStream);
       } catch (IOException e) {
           // It's much easier for us to create a high-quality error
           // message than the low-level C code which found the problem.
           throw new IOException(
           "Cannot run program \"" + prog + "\""
           + (dir == null ? "" : " (in directory \"" + dir + "\")")
           + ": " + e.getMessage(),
           e);
       }
   }
   ```

    　该方法返回一个Process对象，该方法的前面部分相当于是根据命令参数以及设置的工作目录进行一些参数设定，最重要的是try语句块里面的一句： 

   ```java
   return ProcessImpl.start(cmdarray,
                       environment,
                       dir,
                       redirectErrorStream);
   ```

    说明真正创建进程的是这一句，注意调用的是ProcessImpl类的start方法，此处可以知道start必然是一个静态方法。那么ProcessImpl又是什么类呢？该类同样位于java.lang.ProcessImpl路径下，看一下该类的具体实现： 

   ProcessImpl也是一个final类，它继承了Process类： 

   ```java
   final class ProcessImpl extends Process {
    
       // System-dependent portion of ProcessBuilder.start()
       static Process start(String cmdarray[],
                java.util.Map<String,String> environment,
                String dir,
                boolean redirectErrorStream)
       throws IOException
       {
       String envblock = ProcessEnvironment.toEnvironmentBlock(environment);
       return new ProcessImpl(cmdarray, envblock, dir, redirectErrorStream);
       }
    ....
   }
   ```

    　这是ProcessImpl类的start方法的具体实现，而事实上start方法中是通过这句来创建一个ProcessImpl对象的： 

   ```java
   return new ProcessImpl(cmdarray, envblock, dir, redirectErrorStream);
   ```

   　而在ProcessImpl中对Process类中的几个抽象方法进行了具体实现。

   　说明事实上通过ProcessBuilder的start方法创建的是一个ProcessImpl对象。

   　下面看一下具体使用ProcessBuilder创建进程的例子，比如我要通过ProcessBuilder来启动一个进程打开cmd，并获取ip地址信息，那么可以这么写：

   ```java
   public class Test {
       public static void main(String[] args) throws IOException  {
           ProcessBuilder pb = new ProcessBuilder("cmd","/c","ipconfig/all");
           Process process = pb.start();
           Scanner scanner = new Scanner(process.getInputStream());
            
           while(scanner.hasNextLine()){
               System.out.println(scanner.nextLine());
           }
           scanner.close();
       }
   }
   ```

   　第一步是最关键的，就是将命令字符串传给ProcessBuilder的构造器，一般来说，是把字符串中的每个独立的命令作为一个单独的参数，不过也可以按照顺序放入List中传进去。

   　　至于其他很多具体的用法不在此进行赘述，比如通过ProcessBuilder的environment方法和directory(File directory)设置进程的环境变量以及工作目录等，感兴趣的朋友可以查看相关API文档。

#### 2.3.2 通过Runtime的exec方法来创建进程

   　　首先还是来看一下Runtime类和exec方法的具体实现，Runtime，顾名思义，即运行时，表示当前进程所在的虚拟机实例。

   　　由于任何进程只会运行于一个虚拟机实例当中，所以在Runtime中采用了单例模式，即只会产生一个虚拟机实例：

```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();
 
    /**
     * Returns the runtime object associated with the current Java application.
     * Most of the methods of class <code>Runtime</code> are instance
     * methods and must be invoked with respect to the current runtime object.
     *
     * @return  the <code>Runtime</code> object associated with the current
     *          Java application.
     */
    public static Runtime getRuntime() {
    return currentRuntime;
    }
 
    /** Don't let anyone else instantiate this class */
    private Runtime() {}
    ...
 }
```

　从这里可以看出，由于Runtime类的构造器是private的，所以只有通过getRuntime去获取Runtime的实例。接下来着重看一下exec方法 实现，在Runtime中有多个exec的不同重载实现，但真正最后执行的是这个版本的exec方法：

```java
public Process exec(String[] cmdarray, String[] envp, File dir)
   throws IOException {
   return new ProcessBuilder(cmdarray)
       .environment(envp)
       .directory(dir)
       .start();
}
```

 　可以发现，事实上通过Runtime类的exec创建进程的话，最终还是通过ProcessBuilder类的start方法来创建的。

　　下面看一个例子，看一下通过Runtime的exec如何创建进程，还是前面的例子，调用cmd，获取ip地址信息：

```java
public class Test {
    public static void main(String[] args) throws IOException  {
        String cmd = "cmd "+"/c "+"ipconfig /all";
        Process process = Runtime.getRuntime().exec(cmd);
        Scanner scanner = new Scanner(process.getInputStream());
         
        while(scanner.hasNextLine()){
            System.out.println(scanner.nextLine());
        }
        scanner.close();
    }
}
```

 　要注意的是，exec方法不支持不定长参数（ProcessBuilder是支持不定长参数的），所以必须先把命令参数拼接好再传进去。

　　关于在Java中如何创建线程和进程的话，暂时就讲这么多了，感兴趣的朋友可以参考相关资料、

　　参考资料：

　　http://luckykapok918.blog.163.com/blog/static/205865043201210272168556/

　　http://www.cnblogs.com/ChrisWang/archive/2009/12/02/use-java-lang-process-and-processbuilder-to-create-native-application-process.html

　　http://lavasoft.blog.51cto.com/62575/15662/

## 3.[Thread类的使用]( https://www.cnblogs.com/dolphin0520/p/3920357.html )

 学习Thread类，在学习Thread类之前，先介绍与线程相关知识：线程的几种状态、上下文切换，然后接着介绍Thread类中的方法的具体使用 

### 3.1 线程的状态

​		在正式学习Thread类中的具体方法之前，我们先来了解一下线程有哪些状态，这个将会有助于后面对Thread类中的方法的理解。

　　线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：`创建(new)`、`就绪(runnable)`、`运行(running)`、`阻塞(blocked)`、`time waiting`、`waiting`、`消亡（dead）`。

　　当需要新起一个线程来执行某个子任务时，就创建了一个线程。但是线程创建之后，不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源，在前面的JVM内存区域划分一篇博文中知道程序计数器、Java栈、本地方法栈都是线程私有的，所以需要为线程分配一定的内存空间），只有线程运行需要的所有条件满足了，才进入就绪状态。

　　当线程进入就绪状态后，不代表立刻就能获取CPU执行时间，也许此时CPU正在执行其他的事情，因此它要等待。当得到CPU执行时间之后，线程便真正进入运行状态。

　　线程在运行状态过程中，可能有多个原因导致当前线程不继续运行下去，比如用户主动让线程睡眠（睡眠一定的时间之后再重新执行）、用户主动让线程等待，或者被同步块给阻塞，此时就对应着多个状态：time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、blocked（阻塞）。

　　当由于突然中断或者子任务执行完毕，线程就会被消亡。

　　下面这副图描述了线程从创建到消亡之间的状态：

![线程状态](https://images0.cnblogs.com/blog/288799/201409/061045374695226.jpg)

 在有些教程上将blocked、waiting、time waiting统称为阻塞状态，这个也是可以的，只不过这里我想将线程的状态和Java中的方法调用联系起来，所以将waiting和time waiting两个状态分离出来。 

### 3.2 上下文切换

​		对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，当在运行一个线程的过程中转去运行另外一个线程，这个叫做**线程上下文切换**（对于进程也是类似）。

　　由于可能当前线程的任务并没有执行完毕，所以在切换时需要保存线程的运行状态，以便下次重新切换回来时能够继续切换之前的状态运行。举个简单的例子：比如一个线程A正在读取一个文件的内容，正读到文件的一半，此时需要暂停线程A，转去执行线程B，当再次切换回来执行线程A的时候，我们不希望线程A又从文件的开头来读取。

　　因此需要记录线程A的运行状态，那么会记录哪些数据呢？因为下次恢复时需要知道在这之前当前线程已经执行到哪条指令了，所以需要记录程序计数器的值，另外比如说线程正在进行某个计算的时候被挂起了，那么下次继续执行的时候需要知道之前挂起时变量的值时多少，因此需要记录CPU寄存器的状态。所以一般来说，线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。

　　说简单点的：对于*线程的上下文切换*实际上就是**存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行**。

　　虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。

### 3.3 Thread类中的方法

 通过查看java.lang.Thread类的源码可知： 

```java
public
class Thread implements Runnable {
    /* Make sure registerNatives is the first thing <clinit> does. */
    private static native void registerNatives();
    static {
        registerNatives();
    }

    private volatile String name;
    private int            priority;
    private Thread         threadQ;
    private long           eetop;

    /* Whether or not to single_step this thread. */
    private boolean     single_step;

    /* Whether or not the thread is a daemon thread. */
    private boolean     daemon = false;

    /* JVM state */
    private boolean     stillborn = false;

    /* What will be run. */
    private Runnable target;

    /* The group of this thread */
    private ThreadGroup group;

    /* The context ClassLoader for this thread */
    private ClassLoader contextClassLoader;

    /* The inherited AccessControlContext of this thread */
    private AccessControlContext inheritedAccessControlContext;

}
```

　Thread类实现了Runnable接口，在Thread类中，有一些比较关键的属性，比如name是表示Thread的名字，可以通过Thread类的构造器中的参数来指定线程名字，priority表示线程的优先级（最大值为10，最小值为1，默认值为5），daemon表示线程是否是守护线程，target表示要执行的任务。

  下面是Thread类中常用的方法：

  以下是关系到线程运行状态的几个方法：

　1）start方法

　start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。

   2）run方法

​	run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。

  3）sleep方法

 sleep方法有两个重载版本： 

```java
sleep(long millis)     //参数为毫秒
 
sleep(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒
```

sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。

但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。看下面这个例子就清楚了：

```java
public class Test {
     
    private int i = 10;
    private Object object = new Object();
     
    public static void main(String[] args) throws IOException  {
        Test test = new Test();
        MyThread thread1 = test.new MyThread();
        MyThread thread2 = test.new MyThread();
        thread1.start();
        thread2.start();
    } 
     
     
    class MyThread extends Thread{
        @Override
        public void run() {
            synchronized (object) {
                i++;
                System.out.println("i:"+i);
                try {
                    System.out.println("线程"+Thread.currentThread().getName()+"进入睡眠状态");
                    Thread.currentThread().sleep(10000);
                } catch (InterruptedException e) {
                    // TODO: handle exception
                }
                System.out.println("线程"+Thread.currentThread().getName()+"睡眠结束");
                i++;
                System.out.println("i:"+i);
            }
        }
    }
}
```

 输出结果： 

![输出结果](https://images0.cnblogs.com/i/288799/201408/191016230185255.jpg)

从上面输出结果可以看出，当Thread-0进入睡眠状态之后，Thread-1并没有去执行具体的任务。只有当Thread-0执行完之后，此时Thread-0释放了对象锁，Thread-1才开始执行。

　　注意，如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。

　　4）yield方法

　　调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。

　　注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。

　　5）join方法

　　join方法有三个重载版本：

```java
`join()``join(``long` `millis)   ``//参数为毫秒``join(``long` `millis,``int` `nanoseconds)  ``//第一参数为毫秒，第二个参数为纳秒`
```

 　假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的事件。

　　看下面一个例子：

```java
`public` `class` `Test {``  ` `  ``public` `static` `void` `main(String[] args) ``throws` `IOException {``    ``System.out.println(``"进入线程"``+Thread.currentThread().getName());``    ``Test test = ``new` `Test();``    ``MyThread thread1 = test.``new` `MyThread();``    ``thread1.start();``    ``try` `{``      ``System.out.println(``"线程"``+Thread.currentThread().getName()+``"等待"``);``      ``thread1.join();``      ``System.out.println(``"线程"``+Thread.currentThread().getName()+``"继续执行"``);``    ``} ``catch` `(InterruptedException e) {``      ``// TODO Auto-generated catch block``      ``e.printStackTrace();``    ``}``  ``} ``  ` `  ``class` `MyThread ``extends` `Thread{``    ``@Override``    ``public` `void` `run() {``      ``System.out.println(``"进入线程"``+Thread.currentThread().getName());``      ``try` `{``        ``Thread.currentThread().sleep(``5000``);``      ``} ``catch` `(InterruptedException e) {``        ``// TODO: handle exception``      ``}``      ``System.out.println(``"线程"``+Thread.currentThread().getName()+``"执行完毕"``);``    ``}``  ``}``}`
```

 　输出结果：

　　![img](https://images0.cnblogs.com/i/288799/201408/191048580654866.jpg)

　　可以看出，当调用thread1.join()方法后，main线程会进入等待，然后等待thread1执行完之后再继续执行。