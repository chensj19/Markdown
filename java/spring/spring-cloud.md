# spring cloud

## 一、架构演变

### 1. 传统架构

​	在java中使用SSH或者SSM搭建的项目，常规采用MVC架构进行设计，分层开发

	> 存在问题：多人开发，存在代码冲突、任务不好分配、容易产生冲突

### 2.分布式架构

​	基于传统架构演变过来的，将传统的项目以项目模块进行拆分成N多个子项目，比如会员项目、订单项目、支付项目、优惠券项目等等，每个项目中都有自己的独立的数据库、独立的Redis等。

会员项目：登陆、注册、修改密码

订单项目：下单、查询订单、修改订单

* 总结：分布式架构和传统架构区别

 		1.	项目粒度分的更加细致，耦合度降低
 		2.	慢慢开始适合于互联网开发

* maven聚合项目是不是分布式项目：答案是不确定
  * 可以将传统项目，以maven聚合方式分为3个项目，dao/service/web，最终打成一个war包
  * 当项目按照功能进行分割成多个项目，通讯使用RPC进行
  * 最终区别打的jar或war包是多个jvm运行的	

> 项目：包含业务逻辑层和视图层，项目包含前台项目(提供给用户)、后台项目(维护管理)
>
> 服务：只包含业务逻辑层，没有视图层
>
> 中台：管理系统+后台管理系统

### 3.SOA架构

​	业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力

​	通过服务的组合和编排来实现上层的业务流程

​	作用：简化维护,降低整体风险,伸缩灵活

​	SOA架构：面向于服务架构，俗称服务化，是基于分布式架构演变过来的，可以理解为面向于业务逻辑层，将共同的逻辑进行拆分，并抽取出来，提供给其他接口进行调。服务与服务之间通讯采用rpc远程调用技术

​	服务：将共同的业务逻辑进行拆分，拆分成独立一个项目部署，没有视图层，服务概念理解为接口

​	

> RPC远程调用框架：
>
> httpClient、spring cloud、dubbo、grpc
>
> 核心底层socket技术或者netty实现

> WebService 底层采用Http协议+XML(SOAP)
>
> RPC:  远程调用技术，两个或者多个应用实现远程调用

SOA架构特点：

> 底层基于SOAP或者ESB(数据总线)实现的，底层使用http或者https协议+重量级XML数据交换格式进行通讯
>
> 微服务中使用json替代xml，主要区别xml存在很多冗余代码，特别的占用带宽

> SOAP 简单对象协议 http+xml混合 

​	

### 4.微服务架构

1. 微服务架构产生原因

 * SOA架构缺点（微服务架构与SOA架构的区别）
    * SOA架构主要针对企业级、采用ESB服务（ESB企业服务总线），非常重，需要序列化和反序列化，采用XML格式传输
    * 依赖与中心化服务发现机制
    * SOA架构采用SOAP协议(Http+XML),因为XML传输协议比较占用宽带，在整个XML报文中有非常大的冗余数据，所以在微服务架构中以json轻量级方式替代xml报文传输
    * 服务管理非常混乱，缺少服务管理和治理措施不完善

2. 微服务架构模式
   1. 微服务架构是从SOA机构演变过来的，比SOA架构上粒度更加精细。让专业的人做专业的事情(更加专注)，目的是为了提供效率。
   2. 每个服务与服务之间是互不影响，每个服务必须独立部署（独立数据库、独立Redis等），微服务架构更加体现轻量级，采用RESTFUL风格提供API，就是采用http协议+json格式进行传输，更加轻巧，更加适合于互联网公司*敏捷开发*、*快速迭代产品*

> 在项目架构中如何保证项目能够支持多来源(移动端、PC端、微信端、小程序端、H5端)访问？
>
> 那么采用微服务架构模式(包含SOA架构)中该如何划分
>
> 划分为： 
>
> ​	WEB控制层 ：控制页面跳转，采用RPC远程调用SOA服务层
>
> ​	SOA服务层：
>
> WEB控制层： 移动端、小程序端、       PC端、微信端、H5端
>
> ​				 
>
> SOA服务层：会员服务、商品服务、支付服务、交易服务、微信服务、优惠券服务

微服务架构是从SOA架构演变过来的，服务化功能本身在SOA这层已经实现并细化，而在微服务架构中又一次进行细分服务，服务与服务之间可以相互实现通讯

> 比如会员服务：在微服务进行细分：
>
> *SOA*：会员服务 
>
> *微服务机构*  ：会员基本服务+会员联合SSO(单点登录)服务+会员积分服务

## 二、Spring Cloud

1. Spring Cloud 与Spring Boot 区别

   1. Spring Cloud 是基于Spring Boot基础之上的一套非常完整微服务解决方案--基于RPC远程调用，不像其他rpc远程调用框架，只解决某个微服务中的问题，其内容包含服务治理、注册中心、配置管理、断路器、智能路由、微代理、控制总线、全局锁、分布式会话等。
   2. Spring Boot 简化Spring xml配置，快速整合框架

2. 可以把Spring Cloud理解为一条龙微服务解决方案，微服务全家桶，目前功能比较完善

3. Spring Cloud包含多个子项目

   1. Spring Cloud Config 分布式配置中心

   2. Spring Cloud Netflix 核心组件

      1. Eureka：服务治理 注册中心
      2. Hystrix：服务保护框架
      3. Ribbon： 客户端负载均衡器
      4. Feign： 基于Ribbon和Hystrix的声明式调用组件
      5. Zuul： 网关组件，提供智能路由、访问过滤等功能

   3. Spring Cloud组件架构

      ![img](http://img.ccblog.cn/img/20170118/181.jpg)

   4.  组件简介

     *  Spring Cloud Config：配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git以及Subversion。
     *  Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。
     *  Spring Cloud Netflix：针对多种Netflix组件提供的开发工具包，其中包括Eureka、Hystrix、Zuul、Archaius等。
          *  Netflix Eureka：云端负载均衡，一个基于 REST 的服务，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移。
          *  Netflix Hystrix：容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。
          *  Netflix Zuul：边缘服务工具，是提供动态路由，监控，弹性，安全等的边缘服务。
          *  Netflix Archaius：配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。
     *  Spring Cloud for Cloud Foundry：通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。
     *  Spring Cloud Sleuth：日志收集工具包，封装了Dapper,Zipkin和HTrace操作。
     *  Spring Cloud Data Flow：大数据操作工具，通过命令行方式操作数据流。
     *  Spring Cloud Security：安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。
     *  Spring Cloud Consul：封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。
     *  Spring Cloud Zookeeper：操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。
     *  Spring Cloud Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。
     *  Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。

## 三、Eureka 注册中心

### 3.1 服务注册与发现

* RPC远程调用框架，核心设计思想在于注册中心，因为使用注册中心管理每个服务与服务之间的依赖管理(*服务治理*)，可以本地负载均衡、实现服务注册与发现、容错等

* 服务治理
  * 在传统的RPC框架中，管理每个服务与服务之间依赖关系比较复杂

### 3.2 原理

在任何rpc框架中，都会有一个*注册中心*，注册中心主要作用就是存放服务的相关信息

> spring cloud 中支持以下三种注册中心：
>
> Eureka、Consul、Zookeeper
>
> Dubbo支持两种 Redis和Zookeeper

举例：订单服务、注册中心、会员服务

> 流程
>
> 1、首先启动注册中心（Eureka注册中心）  *注册中心*
>
> 2、启动会员服务：会将服务基本信息比如服务地址、接口等信息，以别名方式注册到注册中心
>
> ​	比如：会员服务为127.0.0.1:8080 那么注册中心存放的就是：
>
> ​	ServerId(key):app_member
>
> ​	value:127.0.0.1:8080
>
> ​	类似map
>
> 3、当消费者在调用接口的时候，使用服务别名就是ServerId去注册中心获取实际的远程rpc调用地址
>
> 4、如果消费者获取实际rpc远程调用地址之后，再使用本地HttpClient技术实现调用
>
> ​	*获取的远程RPC地址会缓存在jvm中，Eureka在默认情况下每隔30s更新一次服务调用地址*
>
> 重要概念：
>
> 服务提供者 ： 提供服务接口的意思
>
> 服务消费者 ：调用别人接口进行使用
>
> 一个服务既可以是提供者，也可以是消费者
>
> 服务注册：将服务信息注册到注册中心上
>
> 服务发现：从注册中心获取服务信息
>
> 
>
> 微服务中负载均衡：*本地负载均衡*



