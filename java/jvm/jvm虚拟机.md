# JVM虚拟机

学习JVM原因：

* 面试需要
* 中高级必备技能
  * 项目需要、调优的需要
* 追求极客精神
  * 垃圾算法、JIT、底层原理

## 1.JVM和Java体系结构

### 1.1 Idea 插件 JProfile

注册信息

```bash
# Name填写
脚本之家
#Company填写 
www.jb51.net
# 序列号
L-J11-Everyone#speedzodiac-327a9wrs5dxvz#463a59
A-J11-Everyone#admin-3v7hg353d6idd5#9b4
```

[下载地址](http://fenghuoyunji.jb51.net:81/201903/tools/jprofiler_macos_11_jb51.dmg)

### 1.2 参考书籍

* [Java 8虚拟机规范](https://docs.oracle.com/javase/specs/index.html)

* Java 虚拟机规范(Java SE 8版)

* 深入Java虚拟机
  * JVM高级特性和最佳实践(第二版、第三版)

* 实战Java虚拟机

* Java虚拟机精讲

### 1.3 Java和JVM简介

#### 语言排行

![语言排行榜](jvm%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20200613215539172.png)

#### JVM：跨语言平台

![image-20200613220321390](jvm%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20200613220321390.png)

#### 字节码

Java字节码：用Java语言编译成的字节码，准确来说：任何能在jvm平台上执行的字节码格式都是一样

不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行

Java虚拟机与Java语言并没有必然的联系，它是与特定的二进制文件格式-Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或称为字节码）

#### 多语言混合编程

Java平台上的多语言混合编程正成为主流，通过特定领域语言去解决特定领域的问题。

#### JVM位置

##### 系统层面

![image-20200615194043930](jvm%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20200615194043930.png)

JVM是运行在操作系统之上，与硬件没有直接的交互

##### JDK、JRE、JVM

![image-20200613174822245](jvm%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20200613174822245.png)

#### JVM整体结构

![image-20200615194534652](jvm%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20200615194534652.png)

#### Java代码执行流程

![Java代码执行流程](jvm%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20200615201318339.png)

##### 详细流程

![Java执行详细流程](jvm%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20200615201454497.png)

#### JVM架构模型

Java编译器输入的指令流基本上是一种基于**栈的指令集架构**，另一种指令集架构则是基于**寄存器的指令集架构**

两者对比：

* **基于栈式架构的特点**
  * 设计和实现比较简单，适用于资源受限的系统
  * 避开了寄存器的分配难题：使用零地址指令方式分配
  * 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
  * 不需要硬件支持，可移植性更好，更好实现跨平台
* **基于寄存器架构的特点**
  * 典型的应用是x86的二进制指令集：比如PC和Android的Davlik虚拟机
  * 指令集架构完全依赖硬件，可移植性差
  * 性能优秀和执行更高效
  * 花费更少的指令去完成一项操作
  * 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主

总结：

由于跨平台性的设计，Java的指令都是采用栈来设计，跨平台性、指令集小、指令多；执行性能比寄存器差

#### JVM的生命周期

##### 启动

Java虚拟机的启动时依赖引导类加载器(Bootstrap Class Loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现来指定的

##### 运行

* 一个运行中的Java虚拟机有着一个清晰的任务，执行Java程序
* 程序开始执行时它才允许，程序结束时它就停止
* **执行一个所谓的Java程序的时候，真真正正在执行的是一个Java虚拟机的进程**

##### 结束

## 3、类加载子系统

## 4、运行时数据区

## 5、执行引擎

## 6、stringTable

## 7、垃圾回收



