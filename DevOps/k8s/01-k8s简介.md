# Kubernetes

![images/flower.png](https://d33wubrfki0l68.cloudfront.net/1567471e7c58dc9b7d9c65dcd54e60cbf5870daa/da576/_common-resources/images/flower.png)

## 简介

Kubernetes 是一个开源容器编排引擎，用于容器化应用的自动化部署、扩展和管理。该项目托管在 [CNCF](https://www.cncf.io/about)。

它将组成应用程序的容器组合成逻辑单元，以便于管理和服务发现，Kubernetes 构建在 [Google 15 年生产环境经验](http://queue.acm.org/detail.cfm?id=2898444)基础之上,**并结合来自社区的最佳创意和实践**

### Kubernetes 特性

#### [自动包装](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/)

根据资源需求和其他约束自动放置容器，同时不会牺牲可用性，混合关键和最大努力的工作负载，以提高资源利用率并节省更多资源。

#### [自我修复](https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller)

重新启动失败的容器，在节点不可用时，替换和重新调度节点上的容器，对用户定义的健康检查不响应的容器会被中止，并且在容器准备好服务之前不会把其向客户端广播。

#### [横向缩放](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)

使用简单的命令或 UI，或者根据 CPU 的使用情况自动调整应用程序副本数。

#### [服务发现和负载均衡](https://kubernetes.io/docs/concepts/services-networking/service/)

不需要修改您的应用程序来使用不熟悉的服务发现机制，Kubernetes 为容器提供了自己的 IP 地址和一组容器的单个 DNS 名称，并可以在它们之间进行负载均衡。

#### [自动部署和回滚](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#what-is-a-deployment)

Kubernetes 逐渐部署对应用程序或其配置的更改，同时监视应用程序运行状况，以确保它不会同时终止所有实例。 如果出现问题，Kubernetes会为您恢复更改，利用日益增长的部署解决方案的生态系统。

#### [密钥](https://kubernetes.io/docs/concepts/configuration/secret/) 和 [配置](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/) 管理

部署和更新密钥和应用程序配置，不会重新编译您的镜像，不会在堆栈配置中暴露密钥(secrets)。

#### [存储编排](https://kubernetes.io/docs/concepts/storage/persistent-volumes/)

自动安装您所选择的存储系统，无论是本地存储，如公有云提供商 [GCP](https://cloud.google.com/storage/) 或 [AWS](https://aws.amazon.com/products/storage/), 还是网络存储系统 NFS, iSCSI, Gluster, Ceph, Cinder, 或 Flocker。

#### [批处理](https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/)

除了服务之外，Kubernetes还可以管理您的批处理和 CI 工作负载，如果需要，替换出现故障的容器。

### Kubernetes 可以为您做些什么?

通过现代的 Web 服务，用户希望应用程序能够 24/7 全天候使用，开发人员希望每天可以多次发布部署新版本的应用程序。 容器化可以帮助软件包达成这些目标，使应用程序能够以简单快速的方式发布和更新，而无需停机。Kubernetes 帮助您确保这些容器化的应用程序在您想要的时间和地点运行，并帮助应用程序找到它们需要的资源和工具。 [Kubernetes](http://kubernetes.io/docs/whatisk8s/) 是一个可用于生产的开源平台，根据 Google 容器集群方面积累的经验，以及来自社区的最佳实践而设计。

### 说明

在Kubernetes中，service是核心，我们并不需要太多关心kubernetes里面是怎么工作的，我们只需要关心它给我们提供什么service。就像docker容器可以提供一个mysqld的服务、web服务等。

它需要拥有一个唯一的名字、以及ip:port来对外提供服务。提供service的是容器，为了保证service的高可用，提供service的容器不能只有一个，需要一组，这一组容器我们把它叫做pod。pod是kubernetes最基本的操作单元。

为了实现service和pod之间的管理，又有了标签（label）的概念，我们把功能相同的pod设定为同一个标签。比如，可以把所有提供mysql服务的pod打上标签name=mysql，这样mysql service要作用于所有包含name=mysql标签的pod上。

pod运行在Node上，Node可以是一台物理机，也可以是虚拟机。通常一个Node上会运行几百个pod，每个pod里运行着一个特殊的容器，叫做Pause，其它容器叫做业务容器，业务容器共享Pause容器的网络栈和Volume挂载卷，因此同一个pod内的业务容器之间的通信和数据交换更为高效。

在集群管理方面，kubernetes将集群中的机器划分为一个Master节点和一群工作节点Node，其中Master上运行着kube-apiserver、kube-controller-manager、kube-scheduler，他们实现了资源管理、pod调度、弹性伸缩、安全控制、系统监控、纠错等功能。Node是工作节点，运行应用程序，提供服务。Node上的最小单元是pod，Node上运行着kubernetesd的kubelet、kube-proxy服务进程，它们负责pod的创建、启动、监控、重启、销毁，已经实现负载均衡。

扩容和升级需要一个关键的东西，Replication controller（RC），RC需要包含3个关键信息：

1）目标pod的定义

2）目标pod需要运行的副本数量（replicas）

3）要监控的目标pod的标签（Label）

工作过程：RC里需要定义好3个指标，kubernetes会根据RC定义的Label筛选出对应的pod，并实时监控其状态和数量，当实例数量少于定义的副本数（replicas）时，则会根据RC定义的pod模板来创建新的pod，然后将此pod调度到合适的Node上启动并运行。整个过程完全自动化，无需人工干涉。

## 安装

* 关闭防火墙

```bash
$ systemctl disable firewalld
$ systemctl stop firewalld
```

* 安装etcd和kubernetes

  ```bash
  $ yum install -y etcd kubernetes
  ```

* 启动etcd

  ```bash
  $ systemctl start etcd
  $ systemctl status etcd
  ```

* 修改配置

  ```bash
  # vim /etc/sysconfig/docker
  将   --selinux-enabled   改为   --selinux-enabled=false --insecure-registry gcr.io
  # vim /etc/kubernetes/apiserver
  将  KUBE_ADMISSION_CONTROL  参数中的  ServiceAccount  删除
  ```

* 启动docker

  ```bash
  $ systemctl start docker
  ```

* 启动kubernetes

  ```bash
  $ systemctl start kube-apiserver
  $ systemctl start kube-controller-manager
  $ systemctl start kube-scheduler
  $ systemctl start kubelet
  $ systemctl start kube-proxy
  ```

## 使用

  * 创建配置文件夹

  ```bash
$ mkdir /usr/local/k8s
  ```

### tomcat

1. mytomcat.rc.yaml

```yaml
apiVsersion: v1
kind: ReplicationController
metadata:
 name: mytomcat
spec:
 replicas: 2
 selector:
  app: mytomcat
 template:
  metadata:
   labels:
    app: mytomcat
  spec:
   containers:
    - name: mytomcat
      image: tomcat
      ports:
      - containerPort: 8080
```

```bash
$ kubectl create -f mytomcat.rc.yaml
replicationcontroller "mytomcat" created
# 查看结果
$ kubectl get pods
NAME             READY     STATUS              RESTARTS   AGE
mytomcat-q1hp6   0/1       ContainerCreating   0          56s
mytomcat-z0dhk   0/1       ContainerCreating   0          56s
```

出现两个的问题是因为spec.replicas=2，所以出现了两个

3. mytomcat.svc.yaml

```yaml
kind: Service
metadata:
 name: mytomcat
spec:
 type: NodePort
 ports:
  - port: 8080
    nodePort: 30001
 selector:
  app: mytomcat
```

```bash
$ kubectl create -f mytomcat.svc.yaml
service "mytomcat" created
# 这个镜像如果不拉取的话，将会导致服务不会启动
$ docker pull registry.access.redhat.com/rhel7/pod-infrastructure:latest
# 查看结果
$ kubectl get svc
NAME         CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
kubernetes   10.254.0.1       <none>        443/TCP          19m
mytomcat     10.254.137.102   <nodes>       8080:30001/TCP   53s
```

### mysql

1.  mysql.rc.yaml

```yaml
apiVersion: v1
kind: ReplicationController                         #副本控制器RC
metadata:
  name: mysql                                       #RC的名称，全剧唯一
spec:
  replicas: 1                                       #Pod副本的期待数量
  selector:
    app: mysql                                      #符合目标的Pod拥有此标签
  template:                                         #根据此模板创建Pod的副本（实例）
    metadata:
      labels:
        app: mysql                                   #Pod副本拥有的标签，对应RC的Selector
    spec:
      containers:                                    #Pod内容器的定义部分
      - name: mysql                                  #容器的名称
        image: mysql:5.6                             #容器对应的Docker image
        ports:
        - containerPort: 3306                        #容器应用监听的端口号
        env:                                         #注入容器内的环境变量
        - name: MYSQL_ROOT_PASSWORD                     
          value: "123456"
```

2. 镜像拉取与服务创建

```bash
$ docker pull registry.access.redhat.com/rhel7/pod-infrastructure:latest
$ docker pull mysql:5.6                # 拉取镜像
$ kubectl create -f mysql.rc.yaml      # 创建pod。上面两步可省略，若提前拉取镜像则该步执行更快
replicationcontroller "mysql" created
$ kubectl get pod
NAME          READY     STATUS              RESTARTS   AGE
mysql-f16r2   0/1       ContainerCreating   0          1m      #容器正在创建中
$ kubectl get pod
NAME          READY     STATUS    RESTARTS   AGE
mysql-f16r2   1/1       Running   0          3m                #已经启动
```
* mysql.svc.yaml

```yaml
apiVersion: v1
kind: Service
metadata:
 name: mysql
spec:
 ports:
  - port: 3306
 selector:
  app: mysql
```

```bash
$ kubectl create -f mysql.svc.yaml              #创建service
service "mysql" created
$ kubectl get svc
NAME         CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
kubernetes   10.254.0.1       <none>        443/TCP    58m
mysql        10.254.218.177   <none>        3306/TCP   33s
```

```bash
$yum install -y mysql
$ mysql -uroot -p123456 -h10.254.218.177              #此时就可以直接访问这个mysql服务
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.01 sec)
```

### 节点更新

```bash
# 更新镜像
$ kubectl replace -f mytomcat.rc.yaml
# 删除 service
$ kubectl delete svc --all
# 创建服务
$ kubectl create -f mytomcat.svc.yaml
```

## 问题

### service创建后未启动

service创建后未启动，判断的状态如下：

```bash
$ kubectl get pods
NAME             READY     STATUS              RESTARTS   AGE
mytomcat-q1hp6   0/1       ContainerCreating   0          56s
mytomcat-z0dhk   0/1       ContainerCreating   0          56s
```

* 解决方案

```bash
$ yum install -y python-rhsm-certificates
# 如果提示：Package python-rhsm-certificates-1.19.10-1.el7_4.x86_64 is obsoleted by subscription-manager-rhsm-certificates-1.21.10-3.el7.centos.x86_64 which is already installed
$ wget http://mirror.centos.org/centos/7/os/x86_64/Packages/python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm
$ rpm2cpio python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm | cpio -iv --to-stdout ./etc/rhsm/ca/redhat-uep.pem > /etc/rhsm/ca/redhat-uep.pem
$ docker pull registry.access.redhat.com/rhel7/pod-infrastructure:latest
```
   如果上面解决了问题，那么就不需要执行下面的操作：

docker pull 失败

* 解决方案1 

```bash
$ docker search pod-infrastructure
$ docker pull docker.io/tianyebj/pod-infrastructure
$ docker tag tianyebj/pod-infrastructure 192.168.31.43:5000/pod-infrastructure
$ docker push 192.168.31.43:5000/pod-infrastructure
```

```bash
vim /etc/kubernetes/kubelet
修改
KUBELET_POD_INFRA_CONTAINER="--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest"
为
KUBELET_POD_INFRA_CONTAINER="--pod-infra-container-image=192.168.31.43:5000/pod-infrastructure:latest"
```
 重启服务：

```bash
$ systemctl restart kube-apiserver
$ systemctl restart kube-controller-manager
$ systemctl restart kube-scheduler
$ systemctl restart kubelet
$ systemctl restart kube-proxy
```

  * 解决方案2
```bash
$ docker pull kubernetes/pause
$ docker tag docker.io/kubernetes/pause:latest 192.168.31.43:5000/google_containers/pause_amd64.3.0
$ docker push 192.168.31.43:5000/google_containers/pause_amd64.3.0
```

```bash
vim /etc/kubernetes/kubelet
修改
KUBELET_ARGS=""
为
KUBELET_POD_INFRA_CONTAINER="--pod-infra-container-image=192.168.31.43:5000/google_containers/pause_amd64.3.0"
```
重启服务kubelet：

```bash
$ systemctl restart kubelet
```

### 外网无法访问

  搭建好的k8s中创建的容器，只能在其所在的节点上面curl才能够访问，在其他任何主机上无法访问容器占用的端口

```bash
$ vim /etc/sysctl.conf
# 增加如下内容
net.ipv4.ip_forward=1
```

通过浏览器访问

```
iptables -P FORWARD ACCEPT
```

## 基本架构与常用术语

### 基本架构

Kubernetes集群包含有节点代理kubelet和Master组件(APIs, scheduler, etc)，一切都基于分布式的存储系统。下面这张图是Kubernetes的架构图。

![基本架构](https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.2/docs/design/architecture.png)

在这张系统架构图中，我们把服务分为运行在工作节点上的服务(*node*,右侧)和组成集群级别控制板的服务(*master*,左侧)。

Kubernetes节点有运行应用容器必备的服务，而这些都是受Master的控制。

每次个节点上当然都要运行Docker。Docker来负责所有具体的映像下载和容器运行。

Kubernetes主要由以下几个核心组件组成：

- etcd保存了整个集群的状态；
- apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；
- controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；
- scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；
- kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；
- Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；
- kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；

除了核心组件，还有一些推荐的Add-ons：

- kube-dns负责为整个集群提供DNS服务
- Ingress Controller为服务提供外网入口
- Heapster提供资源监控
- Dashboard提供GUI
- Federation提供跨可用区的集群
- Fluentd-elasticsearch提供集群日志采集、存储与查询

![img](https://feisky.gitbooks.io/kubernetes/architecture/images/14791969222306.png)

![img](https://feisky.gitbooks.io/kubernetes/architecture/images/14791969311297.png)

### 分层架构

Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，如下图所示

![img](https://feisky.gitbooks.io/kubernetes/architecture/images/14937095836427.jpg)

- 核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境
- 应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）
- 管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）
- 接口层：kubectl命令行工具、客户端SDK以及集群联邦
- 生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴
  - Kubernetes外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS应用、ChatOps等
  - Kubernetes内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等

## kubelet

kubelet负责管理[pods](https://www.kubernetes.org.cn/kubernetes-pod)和它们上面的容器，images镜像、volumes、etc。

## kube-proxy

每一个节点也运行一个简单的网络代理和负载均衡（详见[services FAQ](https://github.com/kubernetes/kubernetes/wiki/Services-FAQ) )（PS:官方 英文）。 正如Kubernetes API里面定义的这些服务（详见[the services doc](https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/user-guide/services.md)）（PS:官方 英文）也可以在各种终端中以轮询的方式做一些简单的TCP和UDP传输。

服务端点目前是通过DNS或者环境变量( Docker-links-compatible 和 Kubernetes{FOO}_SERVICE_HOST 及 {FOO}_SERVICE_PORT 变量都支持)。这些变量由服务代理所管理的端口来解析。

## Kubernetes控制面板

Kubernetes控制面板可以分为多个部分。目前它们都运行在一个*master* 节点，然而为了达到高可用性，这需要改变。不同部分一起协作提供一个统一的关于集群的视图。

## etcd

所有master的持续状态都存在etcd的一个实例中。这可以很好地存储配置数据。因为有watch(观察者)的支持，各部件协调中的改变可以很快被察觉。

## Kubernetes API Server

API服务提供[Kubernetes API](https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/api.md) （PS:官方 英文）的服务。这个服务试图通过把所有或者大部分的业务逻辑放到不两只的部件中从而使其具有CRUD特性。它主要处理REST操作，在etcd中验证更新这些对象（并最终存储）。

## Scheduler

调度器把未调度的pod通过binding api绑定到节点上。调度器是可插拔的，并且我们期待支持多集群的调度，未来甚至希望可以支持用户自定义的调度器。

## Kubernetes控制管理服务器

所有其它的集群级别的功能目前都是由控制管理器所负责。例如，端点对象是被端点控制器来创建和更新。这些最终可以被分隔成不同的部件来让它们独自的可插拔。

[replicationcont](https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/user-guide/replication-controller.md)[roller](https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/user-guide/replication-controller.md)（PS:官方 英文）是一种建立于简单的 [pod](https://www.kubernetes.org.cn/kubernetes-pod) API之上的一种机制。一旦实现，我们最终计划把这变成一种通用的插件机制。